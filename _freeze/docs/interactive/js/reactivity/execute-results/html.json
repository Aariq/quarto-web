{
  "hash": "8834f2355eb75b0889ecb71f52288ab0",
  "result": {
    "markdown": "---\ntitle: \"Reactivity\"\n---\n\nThe interactivity in interactive Quarto documents comes from the\n*reactive* values provided by Observable's JavaScript dialect.\n\n# Basics\n\n## Inputs\n\n```{ojs}\n//| echo: false\nmd`There are a number of built-in reactive values in Observable you can use, and they automatically change as needed. For example, the local time of day (in milliseconds) is available as the \\`now\\` variable: ${now}; the width of the Quarto text area is available as \\`width\\`: ${width}. If you use these values as inputs in your code, you expressions will automatically be recomputed as the values change. For the full set of built-in values, see the [standard library documentation](https://github.com/observablehq/stdlib/blob/main/README.md).`\n```\n\nTo obtain values from user input, start with Observable's Inputs\nlibrary, which gives you a simple way to create interactive inputs:\n\n```{ojs}\nviewof number = Inputs.range([10, 100], { value: 50, step: 1 })\nviewof text = Inputs.text()\n```\n\nThat `viewof` statement is special to Observable's runtime.  For now,\njust remember that input value expressions should have `viewof` in\nfront of them.\n\n## Outputs\n\nAn interactive output is just a JavaScript expression. If that\nexpression includes reactive inputs, the Observable runtime library will\nautomatically update the output when the input changes:\n\n```{ojs}\nmd`Output: **You typed \"${text}\" into the text box, and the slider value is ${number}.**`\n```\n\nOutputs can be anything that JavaScript can create, including HTML and\nSVG elements. This green rectangle below will change with the value of the\nslider:\n\n```{ojs}\n//| echo: false\n{\n  let result = DOM.svg(width, 50);\n  let rect = svg`<rect width=${number} height=\"30\" y=\"10\" x=\"10\" fill=\"green\"></rect>`\n  let label = svg`<text>${text}</text>`;\n  result.appendChild(rect);\n  rect.appendChild(label);\n  return result;\n}\n```\n\n# Example: [conditioning on a collider](http://www.the100.ci/2017/03/14/that-one-weird-third-variable-problem-nobody-ever-mentions-conditioning-on-a-collider/)\n\nImagine a simplistic scenario where the **fame** of an actor is a weighted function of **talent** and **looks**, each measured as independent quantities.\n\n```{ojs}\n//| echo: false\nviewof talentWeight = Inputs.range([-2, 2], { value: 0.7, step: 0.01, label: \"talent weight\" })\nviewof looksWeight = Inputs.range([-2, 2], { value: 0.7, step: 0.01, label: \"looks weight\" })\nviewof minimum = Inputs.range([-2, 2], { value: 1, step: 0.01, label: \"minimum fame\" })\n```\n\nThe data for the actors visualization is computed in Python:\n\n::: {.cell}\n``` {.python .cell-code}\nimport numpy\nimport pandas as pd\nojs_define(points = pd.DataFrame(dict(\n    x = numpy.random.randn(100),\n    y = numpy.random.randn(100))))\n```\n\n::: {.cell-output-display}\n```{=html}\n<script type=\"ojs-define\">{\"contents\": [{\"name\": \"points\", \"value\": {\"x\": [0.7702407735, 0.4980018085, -0.5077608908, 0.3063784606, 0.8498832634, -0.4550106822, -0.7855895404, 0.9317398962, 0.8535671246, -1.1794818988, -0.1380632867, 0.8603158212, 1.5794979499, 1.1639514263, -1.1430511547, -1.6990921524, -0.169115366, -1.281456657, 0.6728085436, -1.7431211112, -0.1266504859, -1.4538530189, 1.6728263595, 1.8216907224, 1.8993676808, 0.0339558336, -0.0790556147, -1.6256422259, 2.041956353, 0.3359997619, -0.5708158744, -0.0839655526, -0.6429866214, 0.4413428336, 1.3517069121, 0.0150087812, -0.588168887, 0.9439341897, -1.1302372606, 0.7798400856, 0.2022152123, 0.5517839302, 0.3938929872, 3.21316761, 0.9404884859, -0.3802416115, 0.5531176051, 0.8441149421, 1.5722758837, -0.6426437907, -1.4682855901, -0.1283825201, -0.1567520346, 0.7425032432, 0.7337411348, 0.5216266061, -0.2167973662, 1.612619902, 0.850405638, 0.1705664976, -1.1233181364, -1.5081125596, -0.6747235196, 0.8378556513, -0.9746881866, 0.24776084, 0.3807036433, -0.8473202109, -2.1278409948, -1.3785195508, 1.0113557118, 0.3521328278, 0.7274491776, -0.252760437, 1.0315815849, -0.7146511502, 0.9166797458, 0.4905384761, -1.5591506923, -0.6808097258, 1.5793559195, -0.0799105319, 0.4037255432, 1.4532769335, -0.4934526509, -1.0326821738, -0.1626821442, 0.5950614624, -1.5057575561, -1.1542155746, 0.5284504862, 1.6448537055, 0.250127189, -1.5853987934, -0.2562689056, 0.5175908526, 0.0688847012, -1.7116758766, -1.271835353, -0.6757582017], \"y\": [1.9429994355, -0.2877244419, -0.9428068336, 0.2199240981, -0.6858828688, -0.1695731292, -1.2050361743, 1.5752050237, -0.7887906162, 1.4191667717, -1.3091829063, 0.2843328543, 1.2410576689, -0.3881345131, -0.0404029546, -2.1478876054, -1.4210316667, 1.0369321862, 1.6543804333, 0.8399857668, -1.7932727512, -1.5276125997, -1.7446352774, -2.5189432667, -0.5880987428, -1.6261819924, -1.3104420331, 0.4911538885, -0.8082468312, 1.9385690633, -0.2561746999, 0.3706018646, -0.6909320128, 0.2401494098, 1.9718601688, -0.6440504345, 1.1991153885, 0.0368927232, -1.2609368942, 1.0641637344, 0.7319213217, -0.6885036967, -0.0800672727, 0.8651774163, 1.0354223578, 1.1091755545, 0.3641509044, 0.6534521594, 0.8851093111, -0.1585909031, 0.9463877893, -1.1050112662, -1.412123329, 1.3448979991, 0.8400690474, -2.1117870867, 0.6010957991, -0.4289924725, -0.2358068726, 0.618533581, 0.9874695629, -2.4129681094, 0.6100032215, -1.1814597355, 0.1954246103, 1.232429197, -0.8353681894, 1.0111162861, -0.9029202631, 0.900630847, 0.2946692864, 0.2488568279, -0.2708753496, -0.9836205722, 1.052304582, -0.6776222628, -0.541368522, 2.2990708248, 0.1997787328, 0.6302519542, 1.439244885, 0.0004997433, -0.4295346725, 0.51910535, -0.1625450187, 0.3038658613, -0.9754944609, 1.8472904297, 0.1685675925, 0.74235901, -0.5657324656, -0.7256792221, -0.2856985156, 1.8862161201, 0.844780124, -0.667169063, 1.055753997, -1.3780350612, -0.5958268718, -0.6205139526]}}]}</script>\n```\n:::\n:::\n\n\nThe *fame* value for each actor, on the other hand, uses the JavaScript UI elements and so\nis computed as a JavaScript value:\n\n```{ojs}\n//| output: false \nactors = transpose(points).map(v => ({\n  talent: v.x,\n  looks: v.y,\n  fame: v.x * talentWeight + v.y * looksWeight\n}));\n```\n\nIf we look at actors that are talented or good-looking, a surprising phenomenon happens: there appears to be a causal relationship between two independent variables. \nThis idea that \"the better a famous actor looks, the less talented they are\" manifests itself in our model as a sloped line fit.\nThe reality, however, is that it's simply more common for actors to be good-looking but not too talented or talented but not too good-looking, than it is for actors to be good-looking *and* talented. \n\n```{ojs}\n//| label: fig-collider\n//| fig.cap: \"An example of conditioning on a collider. When you fit a regression line to a dataset that has undergone a selection process that depends on multiple values, there exists a dependency between the two values, but there's no causation relationship.\"\n//| echo: false\n{\n  const result = d3.create(\"svg\").attr(\"width\", width).attr(\"height\", 300);\n  const margin = 20;\n  const xScale = d3.scaleLinear().domain([-2, 2]).range([margin, 300 - margin]);\n  const yScale = d3.scaleLinear().domain([-2, 2]).range([300 - margin, margin]);\n  const points = result\n    .append(\"g\")\n    .selectAll(\"circle\")\n    .data(actors)\n    .join(enter => {\n       const sel = enter\n         .append(\"circle\")\n         .attr(\"r\", 3)\n         .attr(\"cx\", d => xScale(d.talent))\n         .attr(\"cy\", d => yScale(d.looks))\n         .attr(\"fill\", d3.lab(50, 40, 20));\n       return sel.filter(d => d.fame <= minimum)\n         .attr(\"fill\", \"rgb(200, 200, 200)\")\n         .attr(\"r\", 2);\n    });\n    \n  const linearRegression = regression.regressionLinear()\n    .x(d => d.talent)\n    .y(d => d.looks)\n    .domain([-2, 2]);\n\n  const chosenActors = actors\n    .filter(d => d.fame > minimum);\n\n  const line = result\n    .append(\"g\")\n    .append(\"line\")\n    .attr(\"stroke\", d3.lab(20, 40, 20))\n    .attr(\"stroke-width\", 1.5)\n    .datum(linearRegression(chosenActors))\n    .attr(\"x1\", d => xScale(d[0][0]))\n    .attr(\"x2\", d => xScale(d[1][0]))\n    .attr(\"y1\", d => yScale(d[0][1]))\n    .attr(\"y2\", d => yScale(d[1][1]));\n\n\n  const xAxis = d3.axisBottom(xScale).ticks(3);\n  result.append(\"g\")\n    .attr(\"transform\", `translate(0, ${yScale(0)})`)\n    .call(xAxis);\n\n  result.append(\"text\")\n    .attr(\"x\", xScale(0.05))\n    .attr(\"y\", yScale(2))\n    .text(\"Looks\");\n\n  result.append(\"text\")\n    .attr(\"y\", yScale(0))\n    .attr(\"x\", xScale(2))\n    .text(\"Talent\");\n\n  const yAxis = d3.axisLeft(yScale).ticks(3);\n  result.append(\"g\")\n    .attr(\"transform\", `translate(${xScale(0)}, 0)`)\n    .call(yAxis);\n  \n  return result.node();\n}\n```\n\n# More details\n\n## All the inputs in the standard library\n\nThere are many ready-made input UI elements: see the [Observable documentation]() for details.\n\n## Reactivity in depth\n\nTBF\n\n* Generators\n* Converting callback style to reactive style\n* Converting reactive style to callback style\n\n<!-- Includes + Definitions -->\n\n```{ojs}\n//| echo: false\n//| output: false\ntranspose = function(df)\n{\n  const keys = Object.keys(df);\n  return df[keys[0]]\n    .map((v, i) => Object.fromEntries(keys.map(key => [key, df[key][i] || undefined])))\n    .filter(v => Object.values(v).every(e => e !== undefined));\n}\nregression = require('d3-regression@1');\n```\n\n",
    "supporting": [
      "reactivity_files"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js\" integrity=\"sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js\" integrity=\"sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==\" crossorigin=\"anonymous\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n"
      ]
    }
  }
}