---
title: "Shiny for Python"
code-annotations: select
---

{{< include ../_pre-release-feature.qmd >}}

## Introduction

The [Shiny](https://shiny.posit.co/py/) package provides an easy way to build web applications with Python. Quarto documents can also now include embedded Shiny components (e.g. a plot with sliders that control its inputs) or even simple Shiny applications that include several components.

This section covers integrating Shiny with Quarto and assumes that you already have basic familiarity with Shiny. To learn more about Shiny please visit <https://shiny.posit.co/py/>.

{{< include _shiny-requirements.qmd >}}

## Hello, Shiny

Here's a simple example that illustrates embedding Shiny components within a Quarto document:

![](images/hello.png){.border}

Here's the source code for this example:

````python
---
title: "Penguin Flipper Length"
format: html
server: shiny
---

```{{python}}
import seaborn as sns
penguins = sns.load_dataset("penguins")
```

```{{python}}
#| panel: input
from shiny import render, reactive, ui
ui.input_slider("bins", "Number of bins:", 5, 15, 10)
```

```{{python}}
@output
@render.plot
def histogram():
    sns.histplot(data = penguins, x ="flipper_length_mm", 
                 bins=input.bins())
```
````


The main difference between this document and a normal static document is the inclusion of `server: shiny` within the document's options, which instructs Quarto to run a Shiny process behind the document:

```yaml
---
title: "Penguin Flipper Length"
format: html
server: shiny
---
```

Note also that we use the `panel: input` cell option to provide visual separation for inputs. The plot rendering code in the next cell uses normal Shiny reactive output syntax.

We'll cover running and deploying Quarto documents with Shiny components in the article on [Running Documents](running.qmd). Before that though, let's cover a more in-depth example.

## Page Layout

Here's an example that includes multiple inputs as well as a more application-like page layout with a sidebar:

![](images/custom.png){.border}

Here's the source code for this example:

````python
---
title: "Penguin Bills"
format: html
page-layout: full
server: shiny
---

```{{python}}
import seaborn as sns
penguins = sns.load_dataset("penguins")
```

```{{python}}
#| panel: sidebar
from shiny import render, reactive, ui

ui.input_select("x", "Variable:", 
                choices=["bill_length_mm", "bill_depth_mm"])
ui.input_select("dist", "Distribution:", choices=["hist", "kde"])
ui.input_checkbox("rug", "Show rug marks", value = False)
```

```{{python}}
#| panel: fill

@output
@render.plot
def displot():
    sns.displot(
        data=penguins, hue="species", multiple="stack",
        x=input.x(), rug=input.rug(),kind=input.dist())
```
````

There are a couple of things worth noting in this example:

1.  The YAML front-matter includes the `page-layout: full` option (to indicate we want our content to occupy the entire page rather than being centered with padding).

2.  We add `panel: sidebar` and `panel: fill` to the two code cells to specify that we want them laid out in special panel containers.

## In Depth Example

Below is a more in-depth example that demonstrates additional concepts including factoring out setup code, reactive calculations, and more advanced layout constructs. Here is the interactive document we'll be building:

![](images/advanced.png){.border}

The code for this document is below. Click on the various numbered annotations on the right for additional explanation of the techniques used.

````python
---
title: "Palmer Penguins"
format: html
page-layout: full
server: shiny
---

Explore the Palmer Penguins dataset (learn more about the data at <https://github.com/allisonhorst/palmerpenguins/>).

```{{python}} # <1>
#| context: setup   # <1>
import seaborn as sns # <1>
from shiny import render, reactive, ui # <1>
penguins = sns.load_dataset("penguins") # <1>
``` # <1>

::: {.panel-sidebar}  # <2>

### Penguins ![](images/penguins.png){width=50px}

```{{python}}
species = list(penguins["species"].value_counts().index) # <3>
ui.input_checkbox_group(  # <3>
    "species", "Species:", # <3>
    species, selected = species # <3>
)

islands = list(penguins["island"].value_counts().index) # <3>
ui.input_checkbox_group(  # <3>
    "islands", "Islands:",  # <3>
    islands, selected = islands # <3>
) #<3>

@reactive.Calc   # <4>
def filtered_penguins(): # <4>
    data = penguins[penguins["species"].isin(input.species())] # <4>
    data = data[data["island"].isin(input.islands())] # <4>
    data["bill_ratio"] = \ # <4>
        (data["bill_length_mm"] / data["bill_depth_mm"]) # <4>
    return data # <4>
``` #<4>

***

```{{python}}  # <5>
ui.input_select("dist", "Distribution:", choices=["kde", "hist"]) # <5>
ui.input_checkbox("rug", "Show rug marks", value = False) # <5>
``` #<5>  

:::

::: {.panel-tabset}  # <6>

### Plots

```{{python}}
#| layout: [ [100], [50,50] ]  # <7> 

@render.plot  # <8>
def ratio():  # <8>
    return sns.displot(  # <8>
        filtered_penguins(), x = "bill_ratio",  # <8>
        hue = "species", kind = input.dist(), # <8>
        fill = True, rug=input.rug() # <8>
    )
ui.output_plot("ratio", height="400px") # <8>

@render.plot
def depth():
    return sns.displot(
        filtered_penguins(), x = "bill_depth_mm", 
        hue = "species", kind = input.dist(), 
        legend = False, fill = True, rug=input.rug()
    )
ui.output_plot("depth", height = "300px")

@render.plot
def length():
    return sns.displot(
        filtered_penguins(), x = "bill_length_mm", 
        hue = "species", kind = input.dist(), 
        legend=False, fill = True, rug=input.rug()
    )
ui.output_plot("length", height = "300px")
```

### Data

```{{python}}  # <9>
@output # <9>
@render.data_frame # <9>
def dataview(): # <9>
    return render.DataGrid(filtered_penguins(), height = "690px") # <9>
``` #<9>
:::
````

1. The `context: setup` cell option indicates that this code cell should run when the application starts (as opposed to when each new client session starts). Expensive initialization code (e.g. loading data) should be placed in `context: setup`.

2. You can define sidebars using a `.panel-sidebar` div. This enables you to include arbitray content in the sidebar including images, narrative, and links.

3. These checkbox input groups have their contents dynamically driven from the available categories in the `species` and `islands` fields of the dataset.

4. When the user interacts with the checkbox groups this results in a different filtered view of the dataset. The `@reactive.Calc` function recomputes the filtered dataset and makes it available as `filtered_penguins()`.

5. These inputs affect the display of plots but not the contents of the filtered dataset.

6. You can define a tabset using a `.panel-tabset` div (individual tabs are in turn defined using headings, in this case `### Plots` and `### Data`).

7. The `layout` cell option defines how multiple outputs (e.g. plots) within a call should be positioned. Here we specify that there should be two rows, with the top row having a single plot and the second row equally divided between the other two plots.

8. Plots are rendered by referencing the filtered dataset (`filtered_penguins()` as well as the plot display oriented inputs (`input.dist()` and `input.rug()`). Plots are automatically re-rendered when the dataset or these inputs change.

9. The Data tab also references `filtered_penguins()` and is updated whenever the filtered data changes.


## Learning More

To learn more about Shiny for Python interactive documents see the following articles:

-   [Running Documents](running.qmd) covers how to run interactive documents both within VS Code and at the command line, as well as how to deploy them to end users.

-   [Execution Contexts](execution.qmd) goes in depth on when different code cells run (e.g. rendering vs. serving).

-   [Component Layout](/docs/interactive/layout.qmd) enumerates the various techniques you can use to layout interactive components within your documents.

-   [Shiny for Python](https://shiny.posit.co/py/) provides in-depth documentation on all of the available UI and ouput widgets, as well as conceptual discussions on how things work.
