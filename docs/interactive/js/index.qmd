---
title: "JavaScript"
execute:
  echo: false
  output: auto
---

## Overview

Quarto includes native support for [Observable JavaScript](https://observablehq.com/@observablehq/observables-not-javascript), a set of enhancements to vanilla JavaScript created by [Mike Bostock](https://en.wikipedia.org/wiki/Mike_Bostock) (also the author of [D3](https://d3js.org/)). Observable is distinguished by its [reactive runtime](https://github.com/observablehq/runtime), which is especially well suited for interactive data exploration and analysis.

The creators of Observable run a hosted service at <https://observablehq.com/> where you can create and publish notebooks. Additionally, you can use Observable in standalone documents and websites via the [open-source libraries](https://github.com/observablehq) at its core.

Quarto uses these core libraries to enable the use of Observable JavaScript ("OJS") within Quarto documents. You do this by creating `{ojs}` executable code blocks (much like you create `{python}` and `{r}` code blocks in order to execute Python or R code). The rest of this article explains the basics of using OJS with Quarto.

## Example

We'll start with a simple example based on Allison Horst's [Palmer Penguins](https://allisonhorst.github.io/palmerpenguins/) dataset. Here we look at how penguin body mass varies across both sex and species (use the provided inputs to filter the dataset by bill length and island):

```{ojs}
data = FileAttachment("examples/palmer-penguins.csv").csv()
```

```{ojs}
filtered = data.filter(function(penguin) {
  return bill_length_min < penguin.bill_length &&
         islands.includes(penguin.island);
})
```

```{ojs}
//| output: true
viewof bill_length_min = Inputs.range(
  [32, 50], 
  {value: 35, step: 1, label: "Bill length (min):"}
)
viewof islands = Inputs.checkbox(
  ["Torgersen", "Biscoe", "Dream"], 
  { value: ["Torgersen", "Biscoe"], 
    label: "Islands:"
  }
)
```

```{ojs}
//| output: true
Plot.rectY(filtered, 
  Plot.binX(
    {y: "count"}, 
    {x: "body_mass", fill: "species", thresholds: 20}
  ))
  .plot({
    facet: {
      data: filtered,
      x: "sex",
      y: "species",
      marginRight: 80
    },
    marks: [
      Plot.frame(),
    ]
  }
)
```

Let's take a look at the source code for this example. First we create an `{ojs}` cell that reads in some data from a CSV file using a [FileAttachment](https://observablehq.com/@observablehq/file-attachments):

```` java
```{{ojs}}
data = FileAttachment("palmer-penguins.csv").csv()
```
````

The example above doesn't plot all of the data but rather a filtered subset. To create our filter we'll need some inputs, and we'll want to be able to use the values of these inputs in our filtering function. To do this, we use the `viewof` keyword and with some standard [Inputs](https://observablehq.com/@observablehq/inputs):

```` java
```{{ojs}}
viewof bill_length_min = Inputs.range(
  [32, 50], 
  {value: 35, step: 1, label: "Bill length (min):"}
)
viewof islands = Inputs.checkbox(
  ["Torgersen", "Biscoe", "Dream"], 
  { value: ["Torgersen", "Biscoe"], 
    label: "Islands:"
  }
)
```
````

Now we write the filtering function that will transform the `data` read from the CSV using the values of `bill_length_min` and `island`.

``` java
{ojs}
filtered = data.filter(function(penguin) {
  return bill_length_min < penguin.bill_length &&
         islands.includes(penguin.island);
})
```

Here we see reactivity in action: we don't need any special syntax to refer to the dynamic input values, they "just work", and the filtering code is automatically re-run when the inputs change. This works in much the same way a spreadsheet works when you update a cell and other cells that refer to it are recalculated.

Finally, we'll plot the filtered data using [Observable Plot](https://observablehq.com/@observablehq/plot) (an open-source JavaScript library for quick visualization of tabular data):

``` java
{ojs}
Plot.rectY(filtered, 
  Plot.binX(
    {y: "count"}, 
    {x: "body_mass", fill: "species", thresholds: 20}
  ))
  .plot({
    facet: {
      data: filtered,
      x: "sex",
      y: "species",
      marginRight: 80
    },
    marks: [
      Plot.frame(),
    ]
  }
)
```

Note that as with our inputs, we refer to the `filtered` variable with no special syntax---the plotting code will be automatically re-run whenever `filtered` changes (which in turn is updated whenever an input changes).

That's a basic end-to-end example of a simple interactive plot. Below we cover a few more basics then provide links to additional articles that go into more depth.

## Libraries

Our example above made use of several standard libraries, including:

1.  [Observable stdlib](https://github.com/observablehq/stdlib) --- Core primitives for DOM manipulation, file handling, importing code, and much more.

2.  [Observable Inputs](https://github.com/observablehq/inputs) --- Standard inputs controls including sliders, drop-downs, tables, check-boxes, etc.

3.  [Observable Plot](https://github.com/observablehq/plot) --- High level plotting library for exploratory data visualization.

The libraries are somewhat special because they are automatically available within notebooks on <https://observablehq.com> as well as within `{ojs}` cells in Quarto documents.

Using other JavaScript libraries is also straightforward, they just need to be explicitly imported. For example, here we import a few libraries commonly used in JavaScript data visualization:

``` java
```{{ojs}}
d3 = require("d3@6")
arquero = require("arquero") 
vegalite = require("vega-lite")
topojson = require("topojson")
```

The [require](https://github.com/observablehq/stdlib#require) function loads libraries from <https://www.jsdelivr.com/> (which in turn can load NPM modules and libraries hosted on GitHub)

See the article on [Libraries](libraries.qmd) to learn more about using standard and third-party libraries.

## Data Sources

## OJS Cells

## Learning More
