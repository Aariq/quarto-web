---
title: "Dot Density Map"
subtitle: "Originally published at <https://observablehq.com/@neocartocnrs/dotdensity-map>"
author: "neocarto"
date: 2021-03-04
license: mit
format: 
  html:
    code-tools: true
---


Did you know that the first dot density map was designed by **Armand Joseph FrÃ¨re de Montizon** in 1830? [His map](https://upload.wikimedia.org/wikipedia/commons/e/e6/Carte_Philosophique_figurant_la_Population_de_la_France.jpg) represented the French population by departments, with 1 dot for 10,000 people. In this notebook, I propose a method to make dot density maps with [Turf.js](https://observablehq.com/@neocartocnrs/cheat-sheet-turf-js/2). For that, I built the functions **dotsInPoly()** & **dotsInPolys()** (see [helpers]). The resulted map presented here is based on gridded data at different scales (see explanations in the data section below).

::: {.panel-input}

```{ojs}
//| echo: false
viewof peoplePerPoint = Range([0.5, 20], {
  step: 0.5,
  value: 3,
  label: "Dot value"
})
```

```{ojs}
//| echo: false
viewof radius = Range([0.4, 3], {
  value: 1,
  label: "Dot size"
})
```

:::

```{ojs}
//| echo: false
map = {
  const svg = d3
    .create("svg")
    .attr("viewBox", [0, 0, width, height])
    .style("width", "100%")
    .style("height", "auto");

  // Background

  svg
    .append("g")
    .append("path")
    .datum(sphere)
    .attr("class", "graticuleOutline")
    .attr("d", path)
    .style('fill', "#9ACBE3");

  svg
    .append("g")
    .append("path")
    .datum(d3.geoGraticule10())
    .attr("class", "graticule")
    .attr("d", path)
    .attr("clip-path", "url(#clip)")
    .style('fill', "none")
    .style('stroke', "white")
    .style('stroke-width', .8)
    .style('stroke-opacity', .5)
    .style('stroke-dasharray', 2);

  svg
    .append("g")
    .append("path")
    .datum(equator)
    .attr("d", path)
    .style('fill', "none")
    .attr("stroke", "white")
    .style('stroke-width', 1.4)
    .style('stroke-opacity', .5)
    .style('stroke-dasharray', 2);

  svg
    .append("path")
    .datum(land)
    .attr("fill", "#e0daa2")
    .attr("stroke", "#737270")
    .attr("stroke-width", 0.3)
    .attr("d", path);

  if (grid) {
    svg
      .append("path")
      .datum(topojson.feature(gwp4, gwp4.objects["pophex_" + res + "deg"]))
      .attr("fill", "none")
      .attr("stroke", "#731531")
      .attr("stroke-width", 0.3)
      .attr("stroke-opacity", 0.5)
      .attr("d", path);
  }

  svg
    .append("g")
    .attr("fill", "#ba2d55")
    .attr("stroke", "#731531")
    .attr("stroke-width", 0.2)
    .selectAll("circle")
    .data(dotdensitylayer)
    .join("circle")
    .attr("cx", d => projection(d.geometry.coordinates)[0])
    .attr("cy", d => projection(d.geometry.coordinates)[1])
    .attr("r", radius);

  // Layout

  const txtx = 120;

  svg
    .append('line')
    .style("stroke", "#1f235c")
    .style("stroke-width", 1)
    .attr("x1", txtx - 8)
    .attr("y1", 265)
    .attr("x2", txtx - 8)
    .attr("y2", 410);

  var title = svg
    .append("text")
    .attr("y", 260)
    .attr("font-family", "sans-serif")
    .attr("font-weight", "bold")
    .attr("fill", "#1f235c")
    .style("font-size", "30px")
    .attr("fill-opacity", 0.7);

  txttitle.forEach(d => {
    title
      .append("tspan")
      .attr("x", txtx)
      .attr("dy", 30)
      .text(d);
  });

  var source = svg
    .append("text")
    .attr("y", 360)
    .attr("font-family", "sans-serif")
    .attr("fill", "#1f235c")
    .style("font-size", "8px")
    .attr("fill-opacity", 0.5);

  txtsource.forEach(d => {
    source
      .append("tspan")
      .attr("x", txtx)
      .attr("dy", 8)
      .text(d);
  });

  const txtx2 = 790;

  svg
    .append('line')
    .style("stroke", "#1f235c")
    .style("stroke-width", 1)
    .attr("x1", txtx2 + 5)
    .attr("y1", 385)
    .attr("x2", txtx2 + 5)
    .attr("y2", 415);

  var legend = svg
    .append("text")
    .attr("y", 380)
    .attr("text-anchor", "end")
    .attr("font-family", "sans-serif")
    .attr("font-weight", "bold")
    .attr("fill", "#1f235c")
    .style("font-size", "15px")
    .attr("fill-opacity", 0.7);

  txtlegend.forEach(d => {
    legend
      .append("tspan")
      .attr("x", txtx2)
      .attr("dy", 16)
      .text(d);
  });

  return svg.node();
}
```

## Data 

```{ojs}
//| echo: false
viewof res = Range([2, 10], {
  step: 1,
  value: 2,
  label: "Initial resolution (degrees)"
  //format: value => "pophex_" + value + "deg"
})
```


```{ojs}
//| echo: false
viewof grid = Toggle({ label: "Reference grid" })
```


The data used here are the [Gridded Population of the World (GPW), Version 4 (December 2018 edition)](https://sedac.ciesin.columbia.edu/data/collection/gpw-v4), produced by CIESIN (Center for International Earth Science Information Network of the University of Colombia). Here, the data has been aggregated into hexagons of different resolutions and stored in a topojson file. **This work has been done beforehand with the <ins>R language</ins>**. The code is available [here](https://gitlab.huma-num.fr/nlambert/resources/-/blob/master/datasets/ciesin/input/BuildData.R). The smaller the resolution you choose (e.g. 2 degrees), the more accurate the map is.

```{ojs}
gwp4 = d3.json(
  "https://raw.githubusercontent.com/neocarto/resources/master/datasets/ciesin/pophex.topjson"
)
```

```{ojs}
land = d3
  .json(
    "https://raw.githubusercontent.com/neocarto/resources/master/datasets/ciesin/land.topojson"
  )
  .then((r) => topojson.feature(r, r.objects.land))
```

 # Cartography & layout

```{ojs}
width = 1000
```

```{ojs}
height = 500
```

```{ojs}
sphere = ({ type: "Sphere" })
```

```{ojs}
projection = d3.geoNaturalEarth2()
```

```{ojs}
path = d3.geoPath(projection)
```

```{ojs}
equator = ({
  type: "LineString",
  coordinates: [[-180, 0], [-90, 0], [0, 0], [90, 0], [180, 0]]
})
```

```{ojs}
data = topojson.feature(gwp4, gwp4.objects["pophex_" + res + "deg"]).features
```

```{ojs}
dotdensitylayer = dotsInPolys(
  data,
  data.map(d => d.properties.pop2020),
  peoplePerPoint * 1000000
)
```

```{ojs}
txttitle = "World\nPopulation\nin 2020".split("\n")
```

```{ojs}
txtsource = "Map Design: Nicolas Lambert, 2021\nData source: Gridded Population\nof the World, Version 4 (GPWv4),\nCenter for International Earth Science\nInformation Network - CIESIN -\nColumbia University".split(
  "\n"
)
```

```{ojs}
txtlegend = (
  "One point represents\n" +
  peoplePerPoint +
  " million people"
).split("\n")
```

## Helpers 

The important part of the code is here. These two functions basend on turfs.js allows to convert data from polygons to a dot density layer.

```{ojs}
dotsInPoly = (feature, value, valuePerPoint) => {
  let points = [];
  let hits = 0;
  let count = 0;
  const nbdots = Math.round(value / valuePerPoint);
  const bounds = turf.bbox(feature);
  while (hits < nbdots && count < nbdots * 10) {
    const coords = turf.randomPosition(bounds);
    const randomPoint = turf.point(coords);
    if (turf.booleanPointInPolygon(randomPoint, feature)) {
      points.push(randomPoint);
      hits++;
    }
    count++;
  }
  return points;
}
```

```{ojs}
dotsInPolys = (features, data, valuePerPoint) => {
  let result = [];
  for (let i = 0; i < features.length; i++) {
    const dots = dotsInPoly(features[i], data[i], valuePerPoint);
    result = result.concat(dots);
  }
  return result;
}
```

## Appendix

```{ojs}
turf = require("@turf/turf@6")
```

```{ojs}
import { Range, Toggle } from "@observablehq/inputs"
```

```{ojs}
topojson = require('topojson')
```

```{ojs}
//| echo: true
d3 = require("d3@6", "d3-geo-projection@2")
```

