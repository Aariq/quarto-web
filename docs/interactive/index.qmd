---
title: "Interactive Documents"
execute: 
  echo: false
  output: false
---

## Overview

Adding interactivity to an article is a great way to help readers explore the concepts and data you are presenting more deeply. There are three ways to add interactive components to Quarto documents:

1.  Create custom [JavaScript](js/) visualizations using Observable.

2.  Use the [Shiny](shiny/) R package to add interactivity to Knitr engine documents.

3.  Incorporate [Jupyter Widgets](widgets/jupyter.qmd) or [htmlwidgets](widgets/htmlwidgets.qmd) (for the Jupyter and Knitr engines, respectively) into your document.

Each of these techniques has distinct benefits and drawbacks in terms of expressiveness, ease of development, and deployment requirements. We'll touch on these considerations briefly below, then provide links to more in depth documentation for learning more.

## JavaScript

Quarto includes native support for executing [Observable JavaScript](https://observablehq.com/@observablehq/five-minute-introduction), a set of extensions to JavaScript created by [Mike Bostock](https://en.wikipedia.org/wiki/Mike_Bostock) (the creator of [D3](https://d3js.org/)). Observable is distinguished by it's [reactive runtime](https://github.com/observablehq/runtime), which is especially well suited for interactive data exploration and analysis.

For example, here's a scatterplot matrix that allows brushing to select data points in one cell, and highlight them across all other cells:

```{ojs}
//| output: true
swatches({color: z})
```

```{ojs}
//| output: true
viewof selection = {
  const svg = d3.create("svg")
      .attr("viewBox", [-padding, 0, width, width]);

  svg.append("style")
      .text(`circle.hidden { fill: #000; fill-opacity: 1; r: 1px; }`);

  svg.append("g")
      .call(xAxis);

  svg.append("g")
      .call(yAxis);

  const cell = svg.append("g")
    .selectAll("g")
    .data(d3.cross(d3.range(columns.length), d3.range(columns.length)))
    .join("g")
      .attr("transform", ([i, j]) => `translate(${i * size},${j * size})`);

  cell.append("rect")
      .attr("fill", "none")
      .attr("stroke", "#aaa")
      .attr("x", padding / 2 + 0.5)
      .attr("y", padding / 2 + 0.5)
      .attr("width", size - padding)
      .attr("height", size - padding);

  cell.each(function([i, j]) {
    d3.select(this).selectAll("circle")
      .data(data.filter(d => !isNaN(d[columns[i]]) && !isNaN(d[columns[j]])))
      .join("circle")
        .attr("cx", d => x[i](d[columns[i]]))
        .attr("cy", d => y[j](d[columns[j]]));
  });

  const circle = cell.selectAll("circle")
      .attr("r", 3.5)
      .attr("fill-opacity", 0.7)
      .attr("fill", d => z(d.species));

  cell.call(brush, circle, svg);

  svg.append("g")
      .style("font", "bold 10px sans-serif")
      .style("pointer-events", "none")
    .selectAll("text")
    .data(columns)
    .join("text")
      .attr("transform", (d, i) => `translate(${i * size},${i * size})`)
      .attr("x", padding)
      .attr("y", padding)
      .attr("dy", ".71em")
      .text(d => d);

  svg.property("value", [])
  return svg.node();
}
```

```{ojs}
selection
```

```{ojs}
function brush(cell, circle, svg) {
  const brush = d3.brush()
      .extent([[padding / 2, padding / 2], [size - padding / 2, size - padding / 2]])
      .on("start", brushstarted)
      .on("brush", brushed)
      .on("end", brushended);

  cell.call(brush);

  let brushCell;

  // Clear the previously-active brush, if any.
  function brushstarted() {
    if (brushCell !== this) {
      d3.select(brushCell).call(brush.move, null);
      brushCell = this;
    }
  }

  // Highlight the selected circles.
  function brushed({selection}, [i, j]) {
    let selected = [];
    if (selection) {
      const [[x0, y0], [x1, y1]] = selection; 
      circle.classed("hidden",
        d => x0 > x[i](d[columns[i]])
          || x1 < x[i](d[columns[i]])
          || y0 > y[j](d[columns[j]])
          || y1 < y[j](d[columns[j]]));
      selected = data.filter(
        d => x0 < x[i](d[columns[i]])
          && x1 > x[i](d[columns[i]])
          && y0 < y[j](d[columns[j]])
          && y1 > y[j](d[columns[j]]));
    }
    svg.property("value", selected).dispatch("input");
  }

  // If the brush is empty, select all circles.
  function brushended({selection}) {
    if (selection) return;
    svg.property("value", []).dispatch("input");
    circle.classed("hidden", false);
  }
}
```

```{ojs}
x = columns.map(c => d3.scaleLinear()
    .domain(d3.extent(data, d => d[c]))
    .rangeRound([padding / 2, size - padding / 2]))
```

```{ojs}
y = x.map(x => x.copy().range([size - padding / 2, padding / 2]))
```

```{ojs}
z = d3.scaleOrdinal()
    .domain(data.map(d => d.species))
    .range(d3.schemeCategory10)
```

```{ojs}
xAxis = {
  const axis = d3.axisBottom()
      .ticks(6)
      .tickSize(size * columns.length);
  return g => g.selectAll("g").data(x).join("g")
      .attr("transform", (d, i) => `translate(${i * size},0)`)
      .each(function(d) { return d3.select(this).call(axis.scale(d)); })
      .call(g => g.select(".domain").remove())
      .call(g => g.selectAll(".tick line").attr("stroke", "#ddd"));
}
```

```{ojs}
yAxis = {
  const axis = d3.axisLeft()
      .ticks(6)
      .tickSize(-size * columns.length);
  return g => g.selectAll("g").data(y).join("g")
      .attr("transform", (d, i) => `translate(0,${i * size})`)
      .each(function(d) { return d3.select(this).call(axis.scale(d)); })
      .call(g => g.select(".domain").remove())
      .call(g => g.selectAll(".tick line").attr("stroke", "#ddd"));
}
```

```{ojs}
data = d3.csvParse(await FileAttachment("data/penguins.csv").text(), d3.autoType)
```

```{ojs}
columns = data.columns.filter(d => typeof data[0][d] === "number")
```

```{ojs}
width = 954
```

```{ojs}
size = (width - (columns.length + 1) * padding) / columns.length + padding
```

```{ojs}
padding = 28
```

```{ojs}
d3 = require("d3@6")
```

```{ojs}
import {swatches} from "@d3/color-legend"
```

One benefit of using JavaScript for interactive documents is that all the logic and computation is performed on the client (so no server is required for deployment).

To learn more see the articles on [Using JavaScript with Quarto](js/).

## Shiny

The Shiny package provides a flexible, easy to use framework for creating interactive web applications with R. Quarto in turn includes support for embedding Shiny components and applets into documents created with the Knitr engine.

Here's a live example of Shiny interactive components along with a brief explanation of the code required to create them:

::: {.border layout-ncol="2"}
```{=html}
 <iframe id="example1" src="https://gallery.shinyapps.io/goog-trend-index/" style="border: none; width: 100%; height: 720px" frameborder="0"></iframe>
```
<div>

<br/>

Shiny comes with a variety of built in input widgets. With minimal syntax it is possible to include widgets like the ones shown on the left in your apps:

``` r
# Select type of trend to plot
selectInput(inputId = "type", 
            label = strong("Trend index"),
            choices = unique(trend_data$type),
            selected = "Travel")
```

Displaying outputs is equally hassle-free:

``` r
mainPanel(
  plotOutput(outputId = "lineplot", 
             height = "300px"),
)
```

Build your plots or tables as you normally would in R, and make them reactive with a call to the appropriate render function:

``` r
output$lineplot <- renderPlot({
  plot(x = selected_trends()$date, 
       y = selected_trends()$close, 
       type = "l",
       xlab = "Date", 
       ylab = "Trend index")
})
```

</div>
:::

Shiny makes it very straightforward to create interactive documents using only R. Unlike using JavaScript though, you will need to [deploy](shiny/running#deployment) documents that use Shiny to a server.

To learn more see the articles on [Using Shiny with Quarto](shiny/).

## Widgets

[Jupyter Widgets](https://jupyter.org/widgets) and [htmlwidgets](https://www.htmlwidgets.org/) are great ways to incorporate interactivity into your documents if you don't know JavaScript and prefer to work exclusively in Python or R. They also run entirely client-side so can be deployed within normal static HTML documents.

For example, the following Python code is all that is required to embed a Leaflet map into a Jupyter engine document:

```{python}
#| echo: true
#| output: true
from ipyleaflet import Map, Marker, basemaps, basemap_to_tiles
m = Map(
  basemap=basemap_to_tiles(
    basemaps.NASAGIBS.ModisTerraTrueColorCR, "2017-04-08"
  ),
  center=(52.204793, 360.121558),
  zoom=4
)
m.add_layer(Marker(location=(52.204793, 360.121558)))
m
```

To learn more see these articles on using widgets with Quarto:

-   [Jupyter Widgets](widgets/jupyter.qmd) (Jupyter engine).

-   [htmlwidgets](widgets/htmlwidgets.qmd) (Knitr engine).

## Layout

Once you've gotten familiar with using various interactive components see the article on [Component Layout](layout.qmd) to learn how to:

-   Group inputs into an [input panel](layout.qmd#input-panel).

-   Present multiple outputs in a [tabset panel](layout.qmd#tabset-panel).

-   Use a [full page layout](layout.qmd#full-page-layout) rather than the default article layout.

-   Add a [sidebar panel](layout.qmd#sidebar-panel) for inputs in a full page layout.

-   Create custom [panel layouts](layout.qmd#panel-layout) to arrange outputs into rows and columns.
